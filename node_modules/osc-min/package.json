{
  "name": "osc-min",
  "version": "1.1.1",
  "main": "lib/index",
  "author": {
    "name": "Russell McClellan",
    "email": "russell.mcclellan@gmail.com",
    "url": "http://www.russellmcc.com"
  },
  "description": "Simple utilities for open sound control in node.js",
  "keywords": [
    "open sound control",
    "OSC",
    "music control",
    "NIME"
  ],
  "repository": {
    "type": "git",
    "url": "http://github.com/russellmcc/node-osc-min.git"
  },
  "dependencies": {
    "binpack": "~0"
  },
  "devDependencies": {
    "mocha": "*",
    "docket": "0.0.5",
    "coveralls": "*",
    "blanket": "*",
    "mocha-lcov-reporter": "*",
    "coffee-script": ">=1.7.1 <2.0.0",
    "browserify": "^6.1.0",
    "uglify-js": "^2.4.15"
  },
  "config": {
    "blanket": {
      "loader": "./node-loaders/coffee-script",
      "pattern": "lib",
      "data-cover-never": "node_modules"
    }
  },
  "directories": {
    "lib": "lib",
    "examples": "examples"
  },
  "license": "Zlib",
  "engines": {
    "node": ">=0.10.0"
  },
  "scripts": {
    "test": "cake test",
    "coverage": "cake coverage",
    "coveralls": "cake coveralls",
    "doc": "cake doc",
    "prepublish": "cake doc; coffee -c lib/osc-utilities.coffee",
    "browserify": "cake browserify"
  },
  "_id": "osc-min@1.1.1",
  "dist": {
    "shasum": "5e807eb0cde0d1a0d011cd0b4b874768d0d9d661"
  },
  "_from": "osc-min@",
  "readme": "[![build status](https://secure.travis-ci.org/russellmcc/node-osc-min.png)](http://travis-ci.org/russellmcc/node-osc-min) [![Coverage Status](https://coveralls.io/repos/russellmcc/node-osc-min/badge.png?branch=master)](https://coveralls.io/r/russellmcc/node-osc-min?branch=master) [![dependencies](https://david-dm.org/russellmcc/node-osc-min.png)](https://david-dm.org/russellmcc/node-osc-min)\n# osc-min\n\n_simple utilities for open sound control in node.js_\n\nThis package provides some node.js utilities for working with \n[OSC](http://opensoundcontrol.org/), a format for sound and systems control.  \nHere we implement the [OSC 1.1][spec11] specification.  OSC is a transport-independent\nprotocol, so we don't provide any server objects, as you should be able to \nuse OSC over any transport you like.  The most common is probably udp, but tcp\nis not unheard of.\n\n[spec11]: http://opensoundcontrol.org/spec-1_1\n\n----\n## Installation\n \nThe easiest way to get osc-min is through [NPM](http://npmjs.org).\nAfter install npm, you can install osc-min in the current directory with\n \n```\nnpm install osc-min\n```\n \nIf you'd rather get osc-min through github (for example, if you're forking\nit), you still need npm to install dependencies, which you can do with\n \n```\nnpm install --dev\n```\n \nOnce you've got all the dependencies you should be able to run the unit\ntests with \n \n```\nnpm test\nnpm run-script coverage\n```\n\n### For the browser\nIf you want to use this library in a browser, you can build a browserified file (`build/osc-min.js`) with\n\n```\nnpm install --dev\nnpm run-script browserify\n```\n\n----\n## Examples\n### A simple OSC printer;\n```javascript\n\nsock = udp.createSocket(\"udp4\", function(msg, rinfo) {\n  var error, error1;\n  try {\n    return console.log(osc.fromBuffer(msg));\n  } catch (error1) {\n    error = error1;\n    return console.log(\"invalid OSC packet\");\n  }\n});\n\nsock.bind(inport);\n\n```\n### Send a bunch of args every two seconds;\n```javascript\n\nsendHeartbeat = function() {\n  var buf;\n  buf = osc.toBuffer({\n    address: \"/heartbeat\",\n    args: [\n      12, \"sttttring\", new Buffer(\"beat\"), {\n        type: \"integer\",\n        value: 7\n      }\n    ]\n  });\n  return udp.send(buf, 0, buf.length, outport, \"localhost\");\n};\n\nsetInterval(sendHeartbeat, 2000);\n\n```\n### A simple OSC redirecter;\n```javascript\n\nsock = udp.createSocket(\"udp4\", function(msg, rinfo) {\n  var error, error1, redirected;\n  try {\n    redirected = osc.applyAddressTransform(msg, function(address) {\n      return \"/redirect\" + address;\n    });\n    return sock.send(redirected, 0, redirected.length, outport, \"localhost\");\n  } catch (error1) {\n    error = error1;\n    return console.log(\"error redirecting: \" + error);\n  }\n});\n\nsock.bind(inport);\n\n```\n\n\nmore examples are available in the `examples/` directory.\n\n----\n## Exported functions\n\n------\n### .fromBuffer(buffer, [strict])\ntakes a node.js Buffer of a complete _OSC Packet_ and \noutputs the javascript representation, or throws if the buffer is ill-formed.\n\n`strict` is an optional parameter that makes the function fail more often.\n\n----\n### .toBuffer(object, [strict])\ntakes a _OSC packet_ javascript representation as defined below and returns\na node.js Buffer, or throws if the representation is ill-formed.\n\nSee \"JavaScript representations of the OSC types\" below.\n\n----\n### .toBuffer(address, args[], [strict])\nalternative syntax for above.  Assumes this is an _OSC Message_ as defined below,\nand `args` is an array of _OSC Arguments_ or single _OSC Argument_\n\n----\n### .applyAddressTransform(buffer, transform)\ntakes a callback that takes a string and outputs a string,\nand applies that to the address of the message encoded in the buffer,\nand outputs an encoded buffer.\n\nIf the buffer encodes an _OSC Bundle_, this applies the function to each address \nin the bundle.\n\nThere's two subtle reasons you'd want to use this function rather than \ncomposing `fromBuffer` and `toBuffer`:\n  - Future-proofing - if the OSC message uses an argument typecode that\n    we don't understand, calling `fromBuffer` will throw.  The only time\n    when `applyAddressTranform` might fail is if the address is malformed.\n  - Accuracy - javascript represents numbers as 64-bit floats, so some\n    OSC types will not be able to be represented accurately.  If accuracy\n    is important to you, then, you should never convert the OSC message to a\n    javascript representation.\n\n----\n### .applyMessageTransform(buffer, transform)\ntakes a function that takes and returns a javascript _OSC Message_ representation,\nand applies that to each message encoded in the buffer,\nand outputs a new buffer with the new address.\n\nIf the buffer encodes an osc-bundle, this applies the function to each message \nin the bundle.\n\nSee notes above for applyAddressTransform for why you might want to use this.\nWhile this does parse and re-pack the messages, the bundle timetags are left\nin their accurate and prestine state.\n\n----\n### .timetagToDate(ntpTimeTag)\nConvert a timetag array to a JavaScript Date object in your local timezone.\n\nReceived OSC bundles converted with `fromBuffer` will have a timetag array:\n[secondsSince1970, fractionalSeconds]\nThis utility is useful for logging. Accuracy is reduced to milliseconds.\n\n----\n### .dateToTimetag(date)\nConvert a JavaScript Date to a NTP timetag array [secondsSince1970, fractionalSeconds].\n\n`toBuffer` already accepts Dates for timetags so you might not need this function. If you need to schedule bundles with finer than millisecond accuracy then you could use this to help assemble the NTP array.\n\n----\n### .timetagToTimestamp(timeTag)\nConvert a timetag array to the number of seconds since the UNIX epoch.\n\n\n----\n### .timestampToTimetag(timeStamp)\nConvert a number of seconds since the UNIX epoch to a timetag array.\n\n\n----\n## Javascript representations of the OSC types.  \nSee the [spec][spec] for more information on the OSC types.\n\n+ An _OSC Packet_ is an _OSC Message_ or an _OSC Bundle_.\n\n+ An _OSC Message_:\n\n          {\n              oscType : \"message\"\n              address : \"/address/pattern/might/have/wildcards\"\n              args : [arg1,arg2]\n          }\n\n   Where args is an array of _OSC Arguments_.  `oscType` is optional.\n   `args` can be a single element.\n\n+ An _OSC Argument_ is represented as a javascript object with the following layout:\n\n          {\n              type : \"string\"\n              value : \"value\"\n          }\n\n   Where the `type` is one of the following:\n   + `string` - string value\n   + `float` - numeric value\n   + `integer` - numeric value\n   + `blob` - node.js Buffer value\n   + `true` - value is boolean true\n   + `false` - value is boolean false\n   + `null` - no value\n   + `bang` - no value (this is the `I` type tag)\n   + `timetag` - numeric value\n   + `array` - array of _OSC Arguments_\n\n   Note that `type` is always a string - i.e. `\"true\"` rather than `true`.\n  \n   The following non-standard types are also supported:\n   + `double` - numeric value (encodes to a float64 value)\n\n   \n   For messages sent to the `toBuffer` function, `type` is optional.\n   If the argument is not an object, it will be interpreted as either\n   `string`, `float`, `array` or `blob`, depending on its javascript type\n   (String, Number, Array, Buffer, respectively)\n\n+ An _OSC Bundle_ is represented as a javascript object with the following fields:\n\n          {\n              oscType : \"bundle\"\n              timetag : 7\n              elements : [element1, element]\n          }\n\n  `oscType` \"bundle\"\n\n  `timetag` is one of:\n   - `null` - meaning now, the current time.\n     By the time the bundle is received it will too late and depending\n     on the receiver may be discarded or you may be scolded for being late.\n   - `number` - relative seconds from now with millisecond accuracy.\n   - `Date` - a JavaScript Date object in your local time zone.\n    OSC timetags use UTC timezone, so do not try to adjust for timezones,\n    this is not needed.\n   - `Array` - `[numberOfSecondsSince1900, fractionalSeconds]`\n     Both values are `number`s. This gives full timing accuracy of 1/(2^32) seconds.\n\n `elements` is an `Array` of either _OSC Message_ or _OSC Bundle_\n\n\n[spec]: http://opensoundcontrol.org/spec-1_0\n\n----\n## License\nLicensed under the terms found in COPYING (zlib license)\n",
  "readmeFilename": "readme.md",
  "bugs": {
    "url": "https://github.com/russellmcc/node-osc-min/issues"
  },
  "homepage": "https://github.com/russellmcc/node-osc-min",
  "_resolved": "https://registry.npmjs.org/osc-min/-/osc-min-1.1.1.tgz"
}
